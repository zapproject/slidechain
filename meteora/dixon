# zap slidechain integration

Reference here on slidechain core principles.
U.S. PATENT NO. 9608829 and 9836908. 
PATENT PROTECTED; NO license is granted herein. 
A license to use the systems, methods, processes, procedures and derivatives thereof described herein can be issued only by the owner of United States Patents 9,608,829 and 9,936,908 (the "Patents"). 

The system described herein is called a "slidechain" as per the Patents referenced above. 

Slidechain is a system of multiple blockchains called forked blockchains.
Forked chains "fork" off earlier chains.
Slidechain supports intentional, customizable forking.
This forking is positive and meets the needs and preferences of its users.

Customarily, it is understood that blockchains naturally fork from time to time.
Forks are considered to represent disputes over rule sets or protocols;
however, in some cases, forks are malicious attacks by bad actors. 

Customarily with forked chains, only one branch can be considered valid.
Consensus on which chain is valid is customarily determined by the longest chain.
The longest chain represents the chain with the most work put into completing it. 

To allow forked chains without allowing accidental forks, we need a way to verify valid forks.
We also need a way to detect and ignore invalid forks at the same time. 

Slidechain recognizes "forking" and "forked chains" as positive. 
Its general principles are to prioritize user convenience, flexibility and customizability.
It uses a patented system (as per US Patents 9608829 and 9836908).
Slidechain allows customized or "siloed" blockchains.
Using individualized "forked chains," users can customize and privatize data, systems or processes.

The genesis block is a special block that begins the slidechain. 
It is different from other blocks because as the first block there is no previous block.
Thus, there can be no previous block hash, unlike future blocks in the chain. 

The protocol that governs how the genesis chain grows, what data it stores, how forks are created, and how block and chain validity are verified is indicated by a rule set inside each block in the genesis chain, and this rule set is the default set of rules that allows for the creation of forks and the modification of rules in those forks. 

The fork block allows the chain to be forked such that both the genesis chain and the fork chain ("fork chain" is used interchangeably with "forked chain" to distinguish the noun "fork" from the verb "fork" or its infinitive "to fork" or its present tense "forking") are considered valid chains. 

Conventional forks are considered the result of disputes or attacks by malicious actors, and generally, in a blockchain, all forks are eventually ignored and considered invalid except the one representing the longest chain. 

The fork block is special because it works like a standard block, but additionally includes a reference identifying the first block, or root block, in the valid fork. 

The fork block, or forked block, is part of the pre-existing "canonical" blockchain.

The fork block acts as the genesis block, referenced above, for the forked chain even though the fork block itself is part of a canonical chain which has a separate genesis block.

The first block of the forked chain is the root block. 

In either case, any subsequent block that is chained from either the genesis chain, where the original rule set applies, or the fork chain, where the revised rule set applies, can be another fork block creating yet another valid chain fork.

A general principle of slidechain contends that the ability to update the protocol and create new protocols gives slidechain the flexibility to adapt to any future technological need where a blockchain is useful.

The rule sets and other protocols are not defined by this specification, but defined by users of the system at runtime and are customizable based on a scripting, or programming language.  

In one application, the new rule protocol is stored as the payload of the fork block and applied to the root block and each subsequent standard block that chains from the root block; in a different conception, the new rule protocol is stored in the payload of the root block itself, and is applied to each standard block that chains from the root block.

Slidechain conceives of flexibility in amending rulesets, whereas one option is to have a new protocol only be defined for a forked chain and the original protocol remains fixed and applied to the genesis chain (or canonical chain), a second option is to have the genesis chain protocol itself be modified or updated and applied to every future standard block that chains off the genesis chain, in which case the new base protocol would ideally (but not required to) be backwards compatible with the original genesis chain protocol so that all previous data is not rendered obsolete. 

The protocol of a forked chain may impose its own rules for the creation of additional fork blocks on that forked chain. If a chain that does not recognize the validity of multiple branches is required for a particular application, a customized protocol that disallows forking can be created.

The slidechain can have multiple forks, and there is no limit to the number of fork blocks or the frequency of fork blocks in the genesis chain, or in any forked chain which acts as a genesis chain for subsequent forks; in fact, every block in a genesis chain may conceivably be a fork block.

A forked block may allow for more than one fork to chain from it. 

In order for a fork block to allow for multiple forks, it must store a reference to the root block for each chain that chains from it, which requires a section in the block for authorized hashes that can store more than one authorized hash corresponding to a root block. 

According to one embodiment of slidechain, the protocol rules for each forked chain are stored in the root block of each forked chain, and not the fork block itself, while in another embodiment, the protocol rules for multiple forks are stored in the fork block itself, with an identifier that references the root block to which the protocol rules apply.

According to one embodiment of slidechain, the first block in a forked chain is a root block, but it may also be a fork block itself and that block may create one forked chain with a discreet protocol while, for example, the third fork block in that same forked chain, being the first block in a new forked chain, is also a fork block creating a forked chain with its own ruleset and protocol, and according to one embodiment of the slidechain, the chain rule set for each chain is stored in the first block of the chain fork. 

The language used for defining the protocol rules for a forked chain at runtime can be a known computer programming or scripting language, such as, Python, Ruby, Perl, JavaScript, PHP, Scheme, VBScript, Java, Microsoft .Net, C++, C#, C, or a custom-created language for defining the protocol rules. 

A fork block is interconnected with the first block in an intentional fork, called a root block, to create a valid fork chain, insofar as each block in the blockchain contains a hash of the immediately preceding block stored in the previous hash which creates a link going back through the chain from each block and is a key component to making it prohibitively difficult to modify the chain. 

The root block naturally contains in its previous hash a link to the fork block. 

In order to distinguish valid intentional forks from invalid unintentional forks, a hash representing the root block is also stored in the fork block, which creates a two way link where the fork block and the root block each contain a hash reference to the other.

According to one iteration of slidechain, the root block is partially created before the fork block is created, in which event the previous hash, which will come from the fork block, and the nonce are left unspecified at that point, while a payload hash is created from the data stored in the payload, and the payload hash and all the data of the root block, except the previous hash and the nonce which are left unspecified, are used to compute a short hash.

The short hash of the root block is stored as the authorized hash of the fork block, which has a special block component field for "authorized hash" (this is similar to the "ExtraData" field used in some blockchains). 

The unspecified elements must be excluded, because excluding the previous hash from the short hash prevents the situation of having mutually dependent hashes with no known way to find a solution, while excluding the nonce is required because the nonce will later be changed in determining a valid hash for the root block after the previous hash is determined from the fork block, which does not yet exist at that point.

One concept is to provide that the protocol rules that apply to the fork chain beginning with the root block are stored in the fork block payload, in which event a hash is computed based on the fork block payload and stored as the payload hash, and a fork flag is set in the fork block to indicate a valid fork branching from the fork block, while the authorized hash (which represents the root block), is included along with the payload hash and the rest of the fork block data in computing a valid hash for the fork block, which is achieved by repeatedly adjusting the fork block nonce until the resulting hash meets the required proof standard.

Once the fork block hash is computed and stored as the previous hash (which was previously left unspecified) of the root block, a valid root block hash can then be computed by repeatedly adjusting the root block nonce until a hash is produced that meets the required proof standard; recall that as the previous hash and the nonce of the root block are not included in the short hash, they can safely be modified without changing the authorized hash in the fork block, which is essential because any changes to the data used to compute the short hash will cause a mismatch between the short hash and the authorized hash stored in the fork block, breaking the link between the fork block and the root block.

According to one iteration, additional rules are imposed to prevent unauthorized forks from being recognized and the system is configured to ignore exact copies of blocks which can be detected by comparing the block hash or the short hash between two blocks that both reference the same previous block, as the block hash is based at least on the previous hash, nonce, payload hash, timestamp, proof standard, descriptor, fork flag, and optionally the authorized hash, when present. 

According to one iteration, the root block may also be a fork block, and such a root block is called a root fork for purposes of distinguishing it from a regular root block; in this case, if the fork flag in the root block is set, an authorized hash is stored identifying a second root block that begins a valid fork, but when a root block is a fork block (a root fork), the second root block must be created first and the short hash of the second root block is stored as the authorized hash in the root fork block (which to be clear, is a fork block), after which the root fork short hash can then be computed and stored as the authorized hash of the fork block so that once the fork block is created, the block hashes for the fork block, the root fork block, and the second root block can then be computed in the required order, as described above.

As mentioned earlier, according to one iteration, multiple authorized forks may generate from a single fork block if that fork block stores an equal number of multiple authorized hashes, which are stored in a flexible structure that allows storage of one or more short hashes corresponding to one or more root blocks. The protocol rules for each valid fork may be stored in the fork block payload, or in the root blocks for each authorized fork chain respectively.

When a slidechain forks, the authorized root block referenced in the fork block represents one side of the fork, while the other side of the fork is determined by the standard rule for a blockchain where the longest blockchain is considered the valid chain and all other forks are abandoned; the root block which has a short hash that matches the authorized hash in the fork block is automatically recognized as valid regardless of how long the chain from that root block is, and among the remaining two chains, the longest chain is considered the second valid chain and the shorter chain is abandoned by the distributed network.

One iteration of the system provides that the process of creating a valid slidechain fork begins by computing the payload hash for the root block, which payload hash is a mathematical summary of the payload data and does not have to meet any proof standard; after that, the short hash is then computed using at least the payload hash and timestamp as inputs, and may include other parts of the block as well because including more parts of the block in the short hash improves the reliability and security of the slidechain by making it more difficult to spoof an apparently authorized chain fork, and the fork block can then be created with the short hash from the root block stored as the authorized hash in the fork block once the block hash meets the proof standard stored in the fork block by repeatedly adjusting the nonce until a hash is found that meets the proof standard.

The block hash from the fork block is stored as the previous hash (previously unspecified) in the root block, which completes the two-way reference between the fork block and the root block, ensuring that the root block represents an authorized and valid fork from the fork block, and the root block is validated or finalized by finding a block hash that meets the proof standard stored in the root block.

There is a process for verifying the integrity and validity of a slidechain fork, starting when a fork block, indicated by a block with the fork flag set, is checked to see if the root block contains the fork block hash as the root block's previous hash, which requires verifying that the short hash of the root block matches an authorized hash stored in the fork block; then the system reads the protocol from the payload of the fork block or the root block; then the system verifies the descriptor and the payload hash according to the rules specified in the protocol, and verifies that the timestamp meets the requirements specified by the protocol. 

Then the system checks validity of the subsequent blocks on this fork chain according to the rules of the protocol read from the beginning of the fork chain, and applies the protocol to the network messages belonging to this fork chain, which may include determining which network messages belong to this fork chain based on rules in the protocol for identifying relevant network messages.

// Block header components in intentional fork of bitcoin

// Header must be modified to add fields allowing for the fork buildout
// The root block and fork block are no different in this structure
// Every root block can be turned into a fork block
// All blocks in forked bitcoin chain must accommodate multiple downstream forks comprising fork buildout
// Forked bitcoin chain block header adds blank field for authorized hashes which represent the short hash that comes from the root block which is the first block in the desired fork

// Number of authorized hashes = number of desired forks
// Each new block that is created ideally should have an authorized hash field
// Authorized hash field can be left unspecified if no fork desired
// A fork flag can be set when user controlling the specific forked chain wants to turn a fork block into a root block 

###  MORE CODE

  // use base58 encoding or base65

#ifndef BITCOIN_BASE58_H
#define BITCOIN_BASE58_H

#include <span.h>

#include <string>
#include <vector>

/**
 * Encode a byte span as a base58-encoded string
 */
std::string EncodeBase58(Span<const unsigned char> input);

/**
 * Decode a base58-encoded string (str) into a byte vector (vchRet).
 * return true if decoding is successful.
 */
[[nodiscard]] bool DecodeBase58(const std::string& str, std::vector<unsigned char>& vchRet, int max_ret_len);

/**
 * Encode a byte span into a base58-encoded string, including checksum
 */
std::string EncodeBase58Check(Span<const unsigned char> input);

/**
 * Decode a base58-encoded string (str) that includes a checksum into a byte
 * vector (vchRet), return true if decoding is successful
 */
[[nodiscard]] bool DecodeBase58Check(const std::string& str, std::vector<unsigned char>& vchRet, int max_ret_len);

#endif // BITCOIN_BASE58_H

struct CScriptWitness
{
    // Note that this encodes the data elements being pushed, rather than
    // encoding them as a CScript that pushes them.
    std::vector<std::vector<unsigned char> > stack;

    // Some compilers complain without a default constructor
    CScriptWitness() { }

    bool IsNull() const { return stack.empty(); }

    void SetNull() { stack.clear(); stack.shrink_to_fit(); }

    std::string ToString() const;
};

/** A reference to a CScript: the Hash160 of its serialization */
class CScriptID : public BaseHash<uint160>
{
public:
    CScriptID() : BaseHash() {}
    explicit CScriptID(const CScript& in);
    explicit CScriptID(const uint160& in) : BaseHash(in) {}
};

/** Test for OP_SUCCESSx opcodes as defined by BIP342. */
bool IsOpSuccess(const opcodetype& opcode);

bool CheckMinimalPush(const std::vector<unsigned char>& data, opcodetype opcode);

/** Build a script by concatenating other scripts, or any argument accepted by CScript::operator<<. */
template<typename... Ts>
CScript BuildScript(Ts&&... inputs)
{
    CScript ret;
    int cnt{0};

    ([&ret, &cnt] (Ts&& input) {
        if constexpr (std::is_same_v<std::remove_cv_t<std::remove_reference_t<Ts>>, CScript>) {
            // If it is a CScript, extend ret with it. Move or copy the first element instead.
            if (cnt == 0) {
                ret = std::forward<Ts>(input);
            } else {
                ret.insert(ret.end(), input.begin(), input.end());
            }
        } else {
            // Otherwise invoke CScript::operator<<.
            ret << input;
        }
        cnt++;
    } (std::forward<Ts>(inputs)), ...);

    return ret;
}

#endif // BITCOIN_SCRIPT_SCRIPT_H

  // generate block

generateblock "output" ["rawtx/txid",...]

[
  "rawtx/txid",    (string)
  ...
]

{                    (json object)
  "hash" : "hex"     (string) hash of generated block
}

bitcoin-cli generateblock "myaddress" '["rawtx", "mempool_txid"]'



  // number of new blocks to be generated 

generatetoaddress nblocks "address" ( maxtries )
  where "nblocks" = [n]
  where [n] > 0


generatetodescriptor num_blocks "descriptor" ( maxtries )

[           (json array) hashes of blocks generated
  "hex",    (string) blockhash
  ...
]

bitcoin-cli generatetodescriptor [n] "mydesc"
  where num_blocks=[n] 
  and n > 0


getblock "blockhash" 

{                                 (json object)
  "hash" : "hex",                 (string) the block hash (same as provided)
  "confirmations" : n,            (numeric) The number of confirmations, or -1 if the block is not on the main chain
  "size" : n,                     (numeric) The block size
  "strippedsize" : n,             (numeric) The block size excluding witness data
  "weight" : n,                   (numeric) The block weight as defined in BIP 141
  "height" : n,                   (numeric) The block height or index
  "version" : n,                  (numeric) The block version
  "versionHex" : "hex",           (string) The block version formatted in hexadecimal
  "merkleroot" : "hex",           (string) The merkle root
  "tx" : [                        (json array) The transaction ids
    "hex",                        (string) The transaction id
    ...
  ],
  "time" : xxx,                   (numeric) The block time expressed in UNIX epoch time
  "mediantime" : xxx,             (numeric) The median block time expressed in UNIX epoch time
  "nonce" : n,                    (numeric) The nonce
  "bits" : "hex",                 (string) The bits
  "difficulty" : n,               (numeric) The difficulty
  "chainwork" : "hex",            (string) Expected number of hashes required to produce the chain up to this block (in hex)
  "nTx" : n,                      (numeric) The number of transactions in the block
  "previousblockhash" : "hex",    (string) The hash of the previous block
  "nextblockhash" : "hex"         (string) The hash of the next block
}


getblockchaininfo

  {                                         (json object)
  "chain" : "str",                        (string) current network name (main, test, regtest)
  "blocks" : n,                           (numeric) the height of the most-work fully-validated chain. The genesis block has height 0
  "headers" : n,                          (numeric) the current number of headers we have validated
  "bestblockhash" : "str",                (string) the hash of the currently best block
  "difficulty" : n,                       (numeric) the current difficulty
  "mediantime" : n,                       (numeric) median time for the current best block
  "verificationprogress" : n,             (numeric) estimate of verification progress [0..1]
  "initialblockdownload" : true|false,    (boolean) (debug information) estimate of whether this node is in Initial Block Download mode
  "chainwork" : "hex",                    (string) total amount of work in active chain, in hexadecimal
  "size_on_disk" : n,                     (numeric) the estimated size of the block and undo files on disk
  "pruned" : true|false,                  (boolean) if the blocks are subject to pruning
  "pruneheight" : n,                      (numeric) lowest-height complete block stored (only present if pruning is enabled)
  "automatic_pruning" : true|false,       (boolean) whether automatic pruning is enabled (only present if pruning is enabled)
  "prune_target_size" : n,                (numeric) the target size used by pruning (only present if automatic pruning is enabled)
  "softforks" : {                         (json object) status of softforks
    "xxxx" : {                            (json object) name of the softfork
      "type" : "str",                     (string) one of "buried", "bip9"
      "bip9" : {                          (json object) status of bip9 softforks (only for "bip9" type)
        "status" : "str",                 (string) one of "defined", "started", "locked_in", "active", "failed"
        "bit" : n,                        (numeric) the bit (0-28) in the block version field used to signal this softfork (only for "started" status)
        "start_time" : xxx,               (numeric) the minimum median time past of a block at which the bit gains its meaning
        "timeout" : xxx,                  (numeric) the median time past of a block at which the deployment is considered failed if not yet locked in
        "since" : n,                      (numeric) height of the first block to which the status applies
        "statistics" : {                  (json object) numeric statistics about BIP9 signalling for a softfork (only for "started" status)
          "period" : n,                   (numeric) the length in blocks of the BIP9 signalling period
          "threshold" : n,                (numeric) the number of blocks with the version bit set required to activate the feature
          "elapsed" : n,                  (numeric) the number of blocks elapsed since the beginning of the current period
          "count" : n,                    (numeric) the number of blocks with the version bit set in the current period
          "possible" : true|false         (boolean) returns false if there are not enough blocks left in this period to pass activation threshold
        }
      },
      "height" : n,                       (numeric) height of the first block which the rules are or will be enforced (only for "buried" type, or "bip9" type with "active" status)
      "active" : true|false               (boolean) true if the rules are enforced for the mempool and the next block
    },
    ...
  },
  "warnings" : "str"                      (string) any network and blockchain warnings
}

getblockcount

  curl --user myusername --data-binary '{"jsonrpc": "1.0", "id": "curltest", "method": "getblockcount", "params": []}' -H 'content-type: text/plain;' http://127.0.0.1:8332/

getblockfilter "blockhash" ( "filtertype" )

  {                      (json object)
  "filter" : "hex",    (string) the hex-encoded filter data
  "header" : "hex"     (string) the hex-encoded filter header
}

getblockhash height
  
    curl --user myusername --data-binary '{"jsonrpc": "1.0", "id": "curltest", "method": "getblockhash", "params": [1000]}' -H 'content-type: text/plain;' http://127.0.0.1:8332/

getblockstats hash_or_height ( stats )

    {                              (json object)
  "avgfee" : n,                (numeric) Average fee in the block
  "avgfeerate" : n,            (numeric) Average feerate (in satoshis per virtual byte)
  "avgtxsize" : n,             (numeric) Average transaction size
  "blockhash" : "hex",         (string) The block hash (to check for potential reorgs)
  "feerate_percentiles" : [    (json array) Feerates at the 10th, 25th, 50th, 75th, and 90th percentile weight unit (in satoshis per virtual byte)
    n,                         (numeric) The 10th percentile feerate
    n,                         (numeric) The 25th percentile feerate
    n,                         (numeric) The 50th percentile feerate
    n,                         (numeric) The 75th percentile feerate
    n                          (numeric) The 90th percentile feerate
  ],
  "height" : n,                (numeric) The height of the block
  "ins" : n,                   (numeric) The number of inputs (excluding coinbase)
  "maxfee" : n,                (numeric) Maximum fee in the block
  "maxfeerate" : n,            (numeric) Maximum feerate (in satoshis per virtual byte)
  "maxtxsize" : n,             (numeric) Maximum transaction size
  "medianfee" : n,             (numeric) Truncated median fee in the block
  "mediantime" : n,            (numeric) The block median time past
  "mediantxsize" : n,          (numeric) Truncated median transaction size
  "minfee" : n,                (numeric) Minimum fee in the block
  "minfeerate" : n,            (numeric) Minimum feerate (in satoshis per virtual byte)
  "mintxsize" : n,             (numeric) Minimum transaction size
  "outs" : n,                  (numeric) The number of outputs
  "subsidy" : n,               (numeric) The block subsidy
  "swtotal_size" : n,          (numeric) Total size of all segwit transactions
  "swtotal_weight" : n,        (numeric) Total weight of all segwit transactions
  "swtxs" : n,                 (numeric) The number of segwit transactions
  "time" : n,                  (numeric) The block time
  "total_out" : n,             (numeric) Total amount in all outputs (excluding coinbase and thus reward [ie subsidy + totalfee])
  "total_size" : n,            (numeric) Total size of all non-coinbase transactions
  "total_weight" : n,          (numeric) Total weight of all non-coinbase transactions
  "totalfee" : n,              (numeric) The fee total
  "txs" : n,                   (numeric) The number of transactions (including coinbase)
  "utxo_increase" : n,         (numeric) The increase/decrease in the number of unspent outputs
  "utxo_size_inc" : n          (numeric) The increase/decrease in size for the utxo index (not discounting op_return and similar)
}

  // see valid-fork below 

getchaintips

    [                        (json array)
  {                      (json object)
    "height" : n,        (numeric) height of the chain tip
    "hash" : "hex",      (string) block hash of the tip
    "branchlen" : n,     (numeric) zero for main chain, otherwise length of branch connecting the tip to the main chain
    "status" : "str"     (string) status of the chain, "active" for the main chain
                         Possible values for status:
                         1.  "invalid"               This branch contains at least one invalid block
                         2.  "headers-only"          Not all blocks for this branch are available, but the headers are valid
                         3.  "valid-headers"         All blocks are available for this branch, but they were never fully validated
                         4.  "valid-fork"            This branch is not part of the active chain, but is fully validated
                         5.  "active"                This is the tip of the active main chain, which is certainly valid
  },
  ...
]

getblocktemplate ( "template_request" )

bitcoin-cli getblocktemplate '{"rules": ["segwit"]}'

“rules”: [ (json array, required) A list of strings “segwit”, (string, required) (literal) indicates client side segwit support “str”, (string) other client side supported softfork deployment … ],

{                                          (json object)
  "version" : n,                           (numeric) The preferred block version
  "rules" : [                              (json array) specific block rules that are to be enforced
    "str",                                 (string) name of a rule the client must understand to some extent; see BIP 9 for format
    ...
  ],
  "vbavailable" : {                        (json object) set of pending, supported versionbit (BIP 9) softfork deployments
    "rulename" : n,                        (numeric) identifies the bit number as indicating acceptance and readiness for the named softfork rule
    ...
  },
  "vbrequired" : n,                        (numeric) bit mask of versionbits the server requires set in submissions
  "previousblockhash" : "str",             (string) The hash of current highest block
  "transactions" : [                       (json array) contents of non-coinbase transactions that should be included in the next block
    {                                      (json object)
      "data" : "hex",                      (string) transaction data encoded in hexadecimal (byte-for-byte)
      "txid" : "hex",                      (string) transaction id encoded in little-endian hexadecimal
      "hash" : "hex",                      (string) hash encoded in little-endian hexadecimal (including witness data)
      "depends" : [                        (json array) array of numbers
        n,                                 (numeric) transactions before this one (by 1-based index in 'transactions' list) that must be present in the final block if this one is
        ...
      ],
      "fee" : n,                           (numeric) difference in value between transaction inputs and outputs (in satoshis); for coinbase transactions, this is a negative Number of the total collected block fees (ie, not including the block subsidy); if key is not present, fee is unknown and clients MUST NOT assume there isn't one
      "sigops" : n,                        (numeric) total SigOps cost, as counted for purposes of block limits; if key is not present, sigop cost is unknown and clients MUST NOT assume it is zero
      "weight" : n                         (numeric) total transaction weight, as counted for purposes of block limits
    },
    ...
  ],
  "coinbaseaux" : {                        (json object) data that should be included in the coinbase's scriptSig content
    "key" : "hex",                         (string) values must be in the coinbase (keys may be ignored)
    ...
  },
  "coinbasevalue" : n,                     (numeric) maximum allowable input to coinbase transaction, including the generation award and transaction fees (in satoshis)
  "longpollid" : "str",                    (string) an id to include with a request to longpoll on an update to this template
  "target" : "str",                        (string) The hash target
  "mintime" : xxx,                         (numeric) The minimum timestamp appropriate for the next block time, expressed in UNIX epoch time
  "mutable" : [                            (json array) list of ways the block template may be changed
    "str",                                 (string) A way the block template may be changed, e.g. 'time', 'transactions', 'prevblock'
    ...
  ],
  "noncerange" : "hex",                    (string) A range of valid nonces
  "sigoplimit" : n,                        (numeric) limit of sigops in blocks
  "sizelimit" : n,                         (numeric) limit of block size
  "weightlimit" : n,                       (numeric) limit of block weight
  "curtime" : xxx,                         (numeric) current timestamp in UNIX epoch time
  "bits" : "str",                          (string) compressed target of next block
  "height" : n,                            (numeric) The height of the next block
  "default_witness_commitment" : "str"     (string, optional) a valid witness commitment for the unmodified block template
}

getchaintxstats ( nblocks "blockhash" )

    {                                       (json object)
  "time" : xxx,                         (numeric) The timestamp for the final block in the window, expressed in UNIX epoch time
  "txcount" : n,                        (numeric) The total number of transactions in the chain up to that point
  "window_final_block_hash" : "hex",    (string) The hash of the final block in the window
  "window_final_block_height" : n,      (numeric) The height of the final block in the window.
  "window_block_count" : n,             (numeric) Size of the window in number of blocks
  "window_tx_count" : n,                (numeric) The number of transactions in the window. Only returned if "window_block_count" is > 0
  "window_interval" : n,                (numeric) The elapsed time in the window in seconds. Only returned if "window_block_count" is > 0
  "txrate" : n                          (numeric) The average rate of transactions per second in the window. Only returned if "window_interval" is > 0
}

getdifficulty

  curl --user myusername --data-binary '{"jsonrpc": "1.0", "id": "curltest", "method": "getdifficulty", "params": []}' -H 'content-type: text/plain;' http://127.0.0.1:8332/

getmempoolancestors "txid"

  {                                         (json object)
  "transactionid" : {                     (json object)
    "vsize" : n,                          (numeric) virtual transaction size as defined in BIP 141. This is different from actual serialized size for witness transactions as witness data is discounted.
    "weight" : n,                         (numeric) transaction weight as defined in BIP 141.
    "fee" : n,                            (numeric) transaction fee in BTC (DEPRECATED)
    "modifiedfee" : n,                    (numeric) transaction fee with fee deltas used for mining priority (DEPRECATED)
    "time" : xxx,                         (numeric) local time transaction entered pool in seconds since 1 Jan 1970 GMT
    "height" : n,                         (numeric) block height when transaction entered pool
    "descendantcount" : n,                (numeric) number of in-mempool descendant transactions (including this one)
    "descendantsize" : n,                 (numeric) virtual transaction size of in-mempool descendants (including this one)
    "descendantfees" : n,                 (numeric) modified fees (see above) of in-mempool descendants (including this one) (DEPRECATED)
    "ancestorcount" : n,                  (numeric) number of in-mempool ancestor transactions (including this one)
    "ancestorsize" : n,                   (numeric) virtual transaction size of in-mempool ancestors (including this one)
    "ancestorfees" : n,                   (numeric) modified fees (see above) of in-mempool ancestors (including this one) (DEPRECATED)
    "wtxid" : "hex",                      (string) hash of serialized transaction, including witness data
    "fees" : {                            (json object)
      "base" : n,                         (numeric) transaction fee in BTC
      "modified" : n,                     (numeric) transaction fee with fee deltas used for mining priority in BTC
      "ancestor" : n,                     (numeric) modified fees (see above) of in-mempool ancestors (including this one) in BTC
      "descendant" : n                    (numeric) modified fees (see above) of in-mempool descendants (including this one) in BTC
    },
    "depends" : [                         (json array) unconfirmed transactions used as inputs for this transaction
      "hex",                              (string) parent transaction id
      ...
    ],
    "spentby" : [                         (json array) unconfirmed transactions spending outputs from this transaction
      "hex",                              (string) child transaction id
      ...
    ],
    "bip125-replaceable" : true|false,    (boolean) Whether this transaction could be replaced due to BIP125 (replace-by-fee)
    "unbroadcast" : true|false            (boolean) Whether this transaction is currently unbroadcast (initial broadcast not yet acknowledged by any peers)
  },
  ...
}










